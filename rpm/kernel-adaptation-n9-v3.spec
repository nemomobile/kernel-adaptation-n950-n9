# 
# Do NOT Edit the Auto-generated Part!
# Generated by: spectacle version 0.26
# 

Name:       kernel-adaptation-n9

# >> macros
%define kernel_version 3.5.3
# kernel_version_build is the kernel version with the unique build release and flavour, e.g., 2.6.36.2-4.1-device
%define kernel_version_build %{kernel_version}-%{release}-%{kernel_target_hw}
# kernel_devel_dir for includes/kconfig/makefiles and other devel- files
%define kernel_devel_dir %{_prefix}/src/kernels/%{kernel_version_build}
%define _unpackaged_files_terminate_build 0
# << macros
%define builds_vmlinuz 1

Summary:    Kernel Adaptation %{kernel_target_hw}
Version:    3.5.3.20150127.1
Release:    1
Group:      Kernel/Linux Kernel
License:    GPLv2
URL:        https://github.com/nemomobile/kernel-adaptation-n950-n9
Source0:    %{name}-%{version}.tar.bz2
Source1:    %{name}.config
Requires(post): kmod >= 9
BuildRequires:  pkgconfig(ncurses)
BuildRequires:  mer-kernel-checks
BuildRequires:  kmod >= 9
BuildRequires:  perl
BuildRequires:  fdupes
Provides:   kernel = %{version}

%description
Kernel for %{kernel_target_hw}.

%package devel
Summary:    Devel files for %{kernel_target_hw} kernel
Group:      Development/System
Requires:   %{name} = %{version}-%{release}
Provides:   kernel-devel = %{version}

%description devel
Devel for %{kernel_target_hw} kernel


%prep
%setup -q -n %{name}-%{version}/kernel-adaptation-n950-n9

# >> setup
# This should go in the macro section
# Determine the kernel arch and what we're building
# kernel_arch: arm/mips/x86 (for now) .. the ARCH= for the kernel
#
%{lua:
arch = rpm.expand("%{_arch}")
if arch == "arm" or arch == "mips" then
rpm.define("kernel_arch " .. arch)
else
rpm.define("kernel_arch x86")
end

-- This is the common/code name of the hardware adaptation
-- Primarily used in descriptions

name = rpm.expand("%{name}")
pat = "kernel%-adaptation%-(.+)"
start, finish, capture = string.find(name, pat)
if start == nil then
error("Package name "..name.." doesn't match reqired pattern "..pat)
else
rpm.define("kernel_target_hw " ..  capture)
end
}
#cp %{SOURCE1} ./.config

# make sure EXTRAVERSION says what we want it to say
perl -p -i -e "s/^EXTRAVERSION.*/EXTRAVERSION = -%{release}-%{kernel_target_hw}/" Makefile

# Verify this spec is using the latest template version
/usr/bin/mer_verify_kernel_spec 1 --fatal-if-old

# Verify the config meets the current Mer requirements
#/usr/bin/mer_verify_kernel_config .config

echo The target hw is %{kernel_target_hw}
echo The desc is %{summary}

make n9_mer_defconfig

# << setup

%build
# >> build pre

# arm/mips: uImage
# others  : bzImage
%if 0%{?builds_uImage}
make %{?jobs:-j%jobs} uImage
%endif

%if 0%{?builds_vmlinuz}
make %{?jobs:-j%jobs} bzImage
%endif

make %{?jobs:-j%jobs} modules

# << build pre



# >> build post
# << build post

%install
rm -rf %{buildroot}
# >> install pre

# Modules
# Consider : INSTALL_MOD_STRIP
# set srctree and objtree here to make %{buildroot}/lib/modules/%{kernel_version_build}/{source,build}
make INSTALL_MOD_PATH=%{buildroot} modules_install
mkdir -p %{buildroot}/lib/modules/%{kernel_version_build}/
touch %{buildroot}/lib/modules/%{kernel_version_build}/modules.dep

# /boot
mkdir -p %{buildroot}/boot/
make INSTALL_PATH=%{buildroot}/boot/ install

%if 0%{?builds_uImage}
install -m 755 arch/%{kernel_arch}/boot/uImage %{buildroot}/boot/
%endif

%if 0%{?builds_vmlinuz}
install -m 755 arch/%{kernel_arch}/boot/zImage %{buildroot}/boot/vmlinuz-%{kernel_version_build}
%endif

install -m 755 .config %{buildroot}/boot/config-%{kernel_version_build}
install -m 755 System.map %{buildroot}/boot/System.map-%{kernel_version_build}

# And save the headers/makefiles etc for building modules against
#
# This all looks scary, but the end result is supposed to be:
# * all arch relevant include/ files
# * all Makefile/Kconfig files
# * all script/ files

mkdir -p %{buildroot}/%{kernel_devel_dir}

# dirs for additional modules per module-init-tools, kbuild/modules.txt
# first copy everything
cp --parents `find  -type f -name "Makefile*" -o -name "Kconfig*"` %{buildroot}/%{kernel_devel_dir}
cp Module.symvers %{buildroot}/%{kernel_devel_dir}
cp System.map %{buildroot}/%{kernel_devel_dir}
if [ -s Module.markers ]; then
cp Module.markers %{buildroot}/%{kernel_devel_dir}
fi
# then drop all but the needed Makefiles/Kconfig files
rm -rf %{buildroot}/%{kernel_devel_dir}/Documentation
rm -rf %{buildroot}/%{kernel_devel_dir}/scripts
rm -rf %{buildroot}/%{kernel_devel_dir}/include

# Copy all scripts
cp .config %{buildroot}/%{kernel_devel_dir}
cp -a scripts %{buildroot}/%{kernel_devel_dir}
if [ -d arch/%{kernel_arch}/scripts ]; then
cp -a arch/%{kernel_arch}/scripts %{buildroot}/%{kernel_devel_dir}/arch/%{kernel_arch}
fi
# FIXME - what's this trying to do ... if *lds expands to multiple files the -f test will fail.
if [ -f arch/%{kernel_arch}/*lds ]; then
cp -a arch/%{kernel_arch}/*lds %{buildroot}/%{kernel_devel_dir}/arch/%{kernel_arch}/
fi
# Clean any .o files from the 'scripts'
find %{buildroot}/%{kernel_devel_dir}/scripts/ -name \*.o -print0 | xargs -0 rm -f

# arch-specific include files
cp -a --parents arch/%{kernel_arch}/include %{buildroot}/%{kernel_devel_dir}

# arm has include files under plat- and mach- areas (x86/mips don't)
%if "%{?kernel_arch}" == "arm"
cp -a --parents arch/%{kernel_arch}/mach-*/include %{buildroot}/%{kernel_devel_dir}
cp -a --parents arch/%{kernel_arch}/plat-*/include %{buildroot}/%{kernel_devel_dir}
%endif

# normal include files
mkdir -p %{buildroot}/%{kernel_devel_dir}/include

# copy only include/* directories
cp -a $(find include -mindepth 1 -maxdepth 1 -type d) %{buildroot}/%{kernel_devel_dir}/include

# Make sure the Makefile and version.h have a matching timestamp so that
# external modules can be built. Also .conf
touch -r %{buildroot}/%{kernel_devel_dir}/Makefile %{buildroot}/%{kernel_devel_dir}/include/linux/version.h
touch -r %{buildroot}/%{kernel_devel_dir}/.config %{buildroot}/%{kernel_devel_dir}/include/linux/autoconf.h

# Copy .config to include/config/auto.conf so "make prepare" is unnecessary.
cp %{buildroot}/%{kernel_devel_dir}/.config %{buildroot}/%{kernel_devel_dir}/include/config/auto.conf

# mark modules executable so that strip-to-file can strip them
find %{buildroot}/lib/modules/%{kernel_version_build} -name "*.ko" -type f -exec chmod u+x {} \;
# << install pre

# >> install post
ln -s vmlinuz-%{kernel_version_build} %{buildroot}/boot/bzImage
ln -s System.map-%{kernel_version_build} %{buildroot}/boot/System.map
# << install post

%fdupes  %{buildroot}//%{_prefix}/src/kernels/%{kernel_version_build}/

%post
# >> post
# do we really need to call depmod in post? Isn't it called when
# building kernel already if the depmod binary is available during
# build time?
/sbin/depmod -a
# << post

%files
%defattr(-,root,root,-)
/lib/modules/%{kernel_version_build}/*
/boot/System.map-%{kernel_version_build}
/boot/config-%{kernel_version_build}
# >> files

# do we need this? should it be versioned only for x86
/boot/System.map

%if 0%{?builds_vmlinuz}
/boot/vmlinuz-%{kernel_version_build}
/boot/bzImage
%endif

%if 0%{?builds_uImage}
/boot/uImage
%endif

%if 0%{?builds_firmware}
/lib/firmware/*
%endif
# << files

%files devel
%defattr(-,root,root,-)
/%{_prefix}/src/kernels/%{kernel_version_build}/*
/%{_prefix}/src/kernels/%{kernel_version_build}/.config
# >> files devel
# << files devel

